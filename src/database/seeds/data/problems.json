[
  {
    "title": "Two Sum",
    "slug": "two-sum",
    "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\n\n```\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n```\n\n**Example 2:**\n\n```\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n```\n\n**Example 3:**\n\n```\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n```",
    "constraints": "- `2 <= nums.length <= 10^4`\n- `-10^9 <= nums[i] <= 10^9`\n- `-10^9 <= target <= 10^9`\n- Only one valid answer exists.",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "hash-table"],
    "tagSlugs": ["array", "hash-table"],
    "sampleTestcases": [
      {
        "input": "[2,7,11,15]\n9",
        "expectedOutput": "[0,1]",
        "orderIndex": 1,
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "[3,2,4]\n6",
        "expectedOutput": "[1,2]",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[3,3]\n6",
        "expectedOutput": "[0,1]",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations."
      },
      {
        "order": 2,
        "content": "So, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?"
      },
      {
        "order": 3,
        "content": "The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
      }
    ]
  },
  {
    "title": "Reverse Linked List",
    "slug": "reverse-linked-list",
    "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n```\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n```\nInput: head = [1,2]\nOutput: [2,1]\n```\n\n**Example 3:**\n\n```\nInput: head = []\nOutput: []\n```",
    "constraints": "- The number of nodes in the list is the range `[0, 5000]`.\n- `-5000 <= Node.val <= 5000`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["linked-list", "recursion"],
    "tagSlugs": ["linked-list", "recursion"],
    "sampleTestcases": [
      {
        "input": "[1,2,3,4,5]",
        "expectedOutput": "[5,4,3,2,1]",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[1,2]",
        "expectedOutput": "[2,1]",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Think about the iterative approach using three pointers: previous, current, and next."
      },
      {
        "order": 2,
        "content": "Can you solve this recursively? Think about the base case and how to reverse the rest of the list."
      }
    ]
  },
  {
    "title": "Valid Parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\n**Example 1:**\n\n```\nInput: s = \"()\"\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: s = \"()[]{}\"\nOutput: true\n```\n\n**Example 3:**\n\n```\nInput: s = \"(]\"\nOutput: false\n```",
    "constraints": "- `1 <= s.length <= 10^4`\n- `s` consists of parentheses only `'()[]{}'`.",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["string", "stack"],
    "tagSlugs": ["string", "stack"],
    "sampleTestcases": [
      {
        "input": "\"()\"",
        "expectedOutput": "true",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "\"()[]{}\"",
        "expectedOutput": "true",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "\"(]\"",
        "expectedOutput": "false",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use a stack data structure to keep track of opening brackets."
      },
      {
        "order": 2,
        "content": "When you encounter a closing bracket, check if it matches the most recent opening bracket on the stack."
      }
    ]
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "slug": "longest-substring-without-repeating-characters",
    "description": "Given a string `s`, find the length of the **longest substring** without repeating characters.\n\n**Example 1:**\n\n```\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n**Example 2:**\n\n```\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n\n```\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```",
    "constraints": "- `0 <= s.length <= 5 * 10^4`\n- `s` consists of English letters, digits, symbols and spaces.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["string", "hash-table", "sliding-window"],
    "tagSlugs": ["string", "hash-table", "sliding-window"],
    "sampleTestcases": [
      {
        "input": "\"abcabcbb\"",
        "expectedOutput": "3",
        "orderIndex": 1,
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "\"bbbbb\"",
        "expectedOutput": "1",
        "orderIndex": 2,
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "\"pwwkew\"",
        "expectedOutput": "3",
        "orderIndex": 3,
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use the sliding window technique with two pointers."
      },
      {
        "order": 2,
        "content": "Use a hash set or hash map to track characters in the current window."
      },
      {
        "order": 3,
        "content": "When you find a duplicate, move the left pointer to remove characters until the duplicate is gone."
      }
    ]
  },
  {
    "title": "Merge Two Sorted Lists",
    "slug": "merge-two-sorted-lists",
    "description": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists into one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n\n```\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n```\n\n**Example 2:**\n\n```\nInput: list1 = [], list2 = []\nOutput: []\n```\n\n**Example 3:**\n\n```\nInput: list1 = [], list2 = [0]\nOutput: [0]\n```",
    "constraints": "- The number of nodes in both lists is in the range `[0, 50]`.\n- `-100 <= Node.val <= 100`\n- Both `list1` and `list2` are sorted in **non-decreasing** order.",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["linked-list", "recursion"],
    "tagSlugs": ["linked-list", "recursion", "sorting"],
    "sampleTestcases": [
      {
        "input": "[1,2,4]\n[1,3,4]",
        "expectedOutput": "[1,1,2,3,4,4]",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[]\n[]",
        "expectedOutput": "[]",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[]\n[0]",
        "expectedOutput": "[0]",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use a dummy node to simplify the merging process."
      },
      {
        "order": 2,
        "content": "Compare the values of the current nodes from both lists and attach the smaller one to the result."
      }
    ]
  },
  {
    "title": "Binary Tree Inorder Traversal",
    "slug": "binary-tree-inorder-traversal",
    "description": "Given the `root` of a binary tree, return the inorder traversal of its nodes' values.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n\n```\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n```\n\n**Example 2:**\n\n```\nInput: root = []\nOutput: []\n```\n\n**Example 3:**\n\n```\nInput: root = [1]\nOutput: [1]\n```",
    "constraints": "- The number of nodes in the tree is in the range `[0, 100]`.\n- `-100 <= Node.val <= 100`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["tree", "binary-tree", "depth-first-search", "stack"],
    "tagSlugs": ["tree", "binary-tree", "depth-first-search", "stack"],
    "sampleTestcases": [
      {
        "input": "[1,null,2,3]",
        "expectedOutput": "[1,3,2]",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[1]",
        "expectedOutput": "[1]",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Recursive solution is straightforward: visit left subtree, current node, then right subtree."
      },
      {
        "order": 2,
        "content": "For iterative solution, use a stack to simulate the recursion."
      }
    ]
  },
  {
    "title": "Maximum Subarray",
    "slug": "maximum-subarray",
    "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\n**Example 1:**\n\n```\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n\n**Example 2:**\n\n```\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n\n**Example 3:**\n\n```\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```",
    "constraints": "- `1 <= nums.length <= 10^5`\n- `-10^4 <= nums[i] <= 10^4`",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "dynamic-programming", "divide-and-conquer"],
    "tagSlugs": ["array", "dynamic-programming", "divide-and-conquer"],
    "sampleTestcases": [
      {
        "input": "[-2,1,-3,4,-1,2,1,-5,4]",
        "expectedOutput": "6",
        "orderIndex": 1,
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "[1]",
        "expectedOutput": "1",
        "orderIndex": 2,
        "explanation": "The subarray [1] has the largest sum 1."
      },
      {
        "input": "[5,4,-1,7,8]",
        "expectedOutput": "23",
        "orderIndex": 3,
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Try using Kadane's algorithm for an O(n) solution."
      },
      {
        "order": 2,
        "content": "Keep track of the maximum sum ending at the current position."
      },
      {
        "order": 3,
        "content": "If the current sum becomes negative, reset it to 0."
      }
    ]
  },
  {
    "title": "Climbing Stairs",
    "slug": "climbing-stairs",
    "description": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\n**Example 1:**\n\n```\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n```\n\n**Example 2:**\n\n```\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n```",
    "constraints": "- `1 <= n <= 45`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["math", "dynamic-programming", "memoization"],
    "tagSlugs": ["math", "dynamic-programming", "memoization"],
    "sampleTestcases": [
      {
        "input": "2",
        "expectedOutput": "2",
        "orderIndex": 1,
        "explanation": "There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps"
      },
      {
        "input": "3",
        "expectedOutput": "3",
        "orderIndex": 2,
        "explanation": "There are three ways to climb to the top."
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "To reach step n, you could have come from step n-1 or step n-2."
      },
      {
        "order": 2,
        "content": "This is actually a Fibonacci sequence problem!"
      },
      {
        "order": 3,
        "content": "You can solve this using dynamic programming or even just two variables to track the previous two values."
      }
    ]
  },
  {
    "title": "Coin Change",
    "slug": "coin-change",
    "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n**Example 1:**\n\n```\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n```\n\n**Example 2:**\n\n```\nInput: coins = [2], amount = 3\nOutput: -1\n```\n\n**Example 3:**\n\n```\nInput: coins = [1], amount = 0\nOutput: 0\n```",
    "constraints": "- `1 <= coins.length <= 12`\n- `1 <= coins[i] <= 2^31 - 1`\n- `0 <= amount <= 10^4`",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "dynamic-programming", "breadth-first-search"],
    "tagSlugs": ["array", "dynamic-programming", "breadth-first-search"],
    "sampleTestcases": [
      {
        "input": "[1,2,5]\n11",
        "expectedOutput": "3",
        "orderIndex": 1,
        "explanation": "11 = 5 + 5 + 1"
      },
      {
        "input": "[2]\n3",
        "expectedOutput": "-1",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[1]\n0",
        "expectedOutput": "0",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Think about using dynamic programming. What's the minimum number of coins needed for each amount from 0 to target?"
      },
      {
        "order": 2,
        "content": "For each amount, try adding each coin and see if it gives you a better solution."
      },
      {
        "order": 3,
        "content": "Initialize your DP array with a value larger than any possible answer (like amount + 1)."
      }
    ]
  },
  {
    "title": "Merge Intervals",
    "slug": "merge-intervals",
    "description": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n**Example 1:**\n\n```\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n```\n\n**Example 2:**\n\n```\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n```",
    "constraints": "- `1 <= intervals.length <= 10^4`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 10^4`",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "sorting"],
    "tagSlugs": ["array", "sorting"],
    "sampleTestcases": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "expectedOutput": "[[1,6],[8,10],[15,18]]",
        "orderIndex": 1,
        "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
      },
      {
        "input": "[[1,4],[4,5]]",
        "expectedOutput": "[[1,5]]",
        "orderIndex": 2,
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "First, sort the intervals by their start time."
      },
      {
        "order": 2,
        "content": "Then iterate through the sorted intervals and merge overlapping ones."
      },
      {
        "order": 3,
        "content": "Two intervals overlap if the start of the second interval is less than or equal to the end of the first interval."
      }
    ]
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.\n\n**Example 1:**\n\n```\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n```\n\n**Example 2:**\n\n```\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n```",
    "constraints": "- `1 <= prices.length <= 10^5`\n- `0 <= prices[i] <= 10^4`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "dynamic-programming"],
    "tagSlugs": ["array", "dynamic-programming"],
    "sampleTestcases": [
      {
        "input": "[7,1,5,3,6,4]",
        "expectedOutput": "5",
        "orderIndex": 1,
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "[7,6,4,3,1]",
        "expectedOutput": "0",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Track the minimum price seen so far and calculate profit at each step."
      },
      {
        "order": 2,
        "content": "Keep updating the maximum profit as you iterate through the array."
      }
    ]
  },
  {
    "title": "Contains Duplicate",
    "slug": "contains-duplicate",
    "description": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.\n\n**Example 1:**\n\n```\nInput: nums = [1,2,3,1]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: nums = [1,2,3,4]\nOutput: false\n```\n\n**Example 3:**\n\n```\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n```",
    "constraints": "- `1 <= nums.length <= 10^5`\n- `-10^9 <= nums[i] <= 10^9`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "hash-table", "sorting"],
    "tagSlugs": ["array", "hash-table", "set"],
    "sampleTestcases": [
      {
        "input": "[1,2,3,1]",
        "expectedOutput": "true",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[1,2,3,4]",
        "expectedOutput": "false",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[1,1,1,3,3,4,3,2,4,2]",
        "expectedOutput": "true",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use a hash set to track elements you've seen."
      },
      {
        "order": 2,
        "content": "If you encounter an element already in the set, return true."
      }
    ]
  },
  {
    "title": "Product of Array Except Self",
    "slug": "product-of-array-except-self",
    "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n\n**Example 1:**\n\n```\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n```\n\n**Example 2:**\n\n```\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n```",
    "constraints": "- `2 <= nums.length <= 10^5`\n- `-30 <= nums[i] <= 30`\n- The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "prefix-sum"],
    "tagSlugs": ["array", "prefix-sum"],
    "sampleTestcases": [
      {
        "input": "[1,2,3,4]",
        "expectedOutput": "[24,12,8,6]",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[-1,1,0,-3,3]",
        "expectedOutput": "[0,0,9,0,0]",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Think about using prefix and suffix products."
      },
      {
        "order": 2,
        "content": "You can optimize space by building the result array as you go."
      }
    ]
  },
  {
    "title": "Maximum Depth of Binary Tree",
    "slug": "maximum-depth-of-binary-tree",
    "description": "Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n```\n\n**Example 2:**\n\n```\nInput: root = [1,null,2]\nOutput: 2\n```",
    "constraints": "- The number of nodes in the tree is in the range `[0, 10^4]`.\n- `-100 <= Node.val <= 100`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": [
      "tree",
      "binary-tree",
      "depth-first-search",
      "breadth-first-search"
    ],
    "tagSlugs": ["tree", "binary-tree", "depth-first-search", "recursion"],
    "sampleTestcases": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "expectedOutput": "3",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[1,null,2]",
        "expectedOutput": "2",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use recursion: the depth is 1 + max(depth of left subtree, depth of right subtree)."
      },
      {
        "order": 2,
        "content": "Base case: if the node is null, return 0."
      }
    ]
  },
  {
    "title": "Same Tree",
    "slug": "same-tree",
    "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n**Example 1:**\n\n```\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n```\n\n**Example 3:**\n\n```\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n```",
    "constraints": "- The number of nodes in both trees is in the range `[0, 100]`.\n- `-10^4 <= Node.val <= 10^4`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["tree", "binary-tree", "depth-first-search"],
    "tagSlugs": ["tree", "binary-tree", "depth-first-search", "recursion"],
    "sampleTestcases": [
      {
        "input": "[1,2,3]\n[1,2,3]",
        "expectedOutput": "true",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[1,2]\n[1,null,2]",
        "expectedOutput": "false",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[1,2,1]\n[1,1,2]",
        "expectedOutput": "false",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use recursion to compare nodes at each level."
      },
      {
        "order": 2,
        "content": "Check if both nodes are null, or if one is null and the other isn't, or if their values differ."
      }
    ]
  },
  {
    "title": "Invert Binary Tree",
    "slug": "invert-binary-tree",
    "description": "Given the `root` of a binary tree, invert the tree, and return its root.\n\n**Example 1:**\n\n```\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n```\n\n**Example 2:**\n\n```\nInput: root = [2,1,3]\nOutput: [2,3,1]\n```\n\n**Example 3:**\n\n```\nInput: root = []\nOutput: []\n```",
    "constraints": "- The number of nodes in the tree is in the range `[0, 100]`.\n- `-100 <= Node.val <= 100`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": [
      "tree",
      "binary-tree",
      "depth-first-search",
      "breadth-first-search"
    ],
    "tagSlugs": ["tree", "binary-tree", "depth-first-search", "recursion"],
    "sampleTestcases": [
      {
        "input": "[4,2,7,1,3,6,9]",
        "expectedOutput": "[4,7,2,9,6,3,1]",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[2,1,3]",
        "expectedOutput": "[2,3,1]",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[]",
        "expectedOutput": "[]",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Swap the left and right children of each node recursively."
      },
      {
        "order": 2,
        "content": "Can also be solved iteratively using a queue (BFS)."
      }
    ]
  },
  {
    "title": "Symmetric Tree",
    "slug": "symmetric-tree",
    "description": "Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\n**Example 1:**\n\n```\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n```",
    "constraints": "- The number of nodes in the tree is in the range `[1, 1000]`.\n- `-100 <= Node.val <= 100`",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": [
      "tree",
      "binary-tree",
      "depth-first-search",
      "breadth-first-search"
    ],
    "tagSlugs": ["tree", "binary-tree", "depth-first-search", "recursion"],
    "sampleTestcases": [
      {
        "input": "[1,2,2,3,4,4,3]",
        "expectedOutput": "true",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[1,2,2,null,3,null,3]",
        "expectedOutput": "false",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "A tree is symmetric if the left subtree is a mirror reflection of the right subtree."
      },
      {
        "order": 2,
        "content": "Write a helper function to check if two trees are mirrors of each other."
      }
    ]
  },
  {
    "title": "Linked List Cycle",
    "slug": "linked-list-cycle",
    "description": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer.\n\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\n\n**Example 1:**\n\n```\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n```\n\n**Example 2:**\n\n```\nInput: head = [1,2], pos = 0\nOutput: true\n```\n\n**Example 3:**\n\n```\nInput: head = [1], pos = -1\nOutput: false\n```",
    "constraints": "- The number of the nodes in the list is in the range `[0, 10^4]`.\n- `-10^5 <= Node.val <= 10^5`\n- `pos` is `-1` or a valid index in the linked-list.",
    "difficulty": "easy",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["linked-list", "two-pointers", "hash-table"],
    "tagSlugs": ["linked-list", "two-pointers", "hash-table"],
    "sampleTestcases": [
      {
        "input": "[3,2,0,-4]\n1",
        "expectedOutput": "true",
        "orderIndex": 1,
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node."
      },
      {
        "input": "[1,2]\n0",
        "expectedOutput": "true",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[1]\n-1",
        "expectedOutput": "false",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use Floyd's Cycle Detection Algorithm (tortoise and hare)."
      },
      {
        "order": 2,
        "content": "Use two pointers: slow moves one step at a time, fast moves two steps. If they meet, there's a cycle."
      }
    ]
  },
  {
    "title": "Number of Islands",
    "slug": "number-of-islands",
    "description": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return the number of islands.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n**Example 1:**\n\n```\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```\n\n**Example 2:**\n\n```\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n```",
    "constraints": "- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 300`\n- `grid[i][j]` is `'0'` or `'1'`.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": [
      "array",
      "depth-first-search",
      "breadth-first-search",
      "matrix",
      "union-find"
    ],
    "tagSlugs": [
      "array",
      "depth-first-search",
      "breadth-first-search",
      "matrix"
    ],
    "sampleTestcases": [
      {
        "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
        "expectedOutput": "1",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
        "expectedOutput": "3",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use DFS or BFS to explore each island."
      },
      {
        "order": 2,
        "content": "When you find a '1', increment the island count and mark all connected '1's as visited."
      }
    ]
  },
  {
    "title": "Rotting Oranges",
    "slug": "rotting-oranges",
    "description": "You are given an `m x n` grid where each cell can have one of three values:\n\n- `0` representing an empty cell,\n- `1` representing a fresh orange, or\n- `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`.\n\n**Example 1:**\n\n```\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n```\n\n**Example 2:**\n\n```\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten.\n```\n\n**Example 3:**\n\n```\nInput: grid = [[0,2]]\nOutput: 0\n```",
    "constraints": "- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 10`\n- `grid[i][j]` is `0`, `1`, or `2`.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "breadth-first-search", "matrix"],
    "tagSlugs": ["array", "breadth-first-search", "matrix"],
    "sampleTestcases": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]",
        "expectedOutput": "4",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,1]]",
        "expectedOutput": "-1",
        "orderIndex": 2,
        "explanation": "The orange in the bottom left corner is never rotten."
      },
      {
        "input": "[[0,2]]",
        "expectedOutput": "0",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use BFS starting from all rotten oranges simultaneously."
      },
      {
        "order": 2,
        "content": "Track the number of fresh oranges and decrease it as they rot."
      },
      {
        "order": 3,
        "content": "Count the number of minutes (BFS levels) until all fresh oranges are rotten."
      }
    ]
  },
  {
    "title": "Course Schedule",
    "slug": "course-schedule",
    "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n**Example 1:**\n\n```\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\n```\n\n**Example 2:**\n\n```\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n```",
    "constraints": "- `1 <= numCourses <= 2000`\n- `0 <= prerequisites.length <= 5000`\n- `prerequisites[i].length == 2`\n- `0 <= ai, bi < numCourses`\n- All the pairs prerequisites[i] are **unique**.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": [
      "graph",
      "depth-first-search",
      "breadth-first-search",
      "topological-sort"
    ],
    "tagSlugs": ["graph", "depth-first-search", "topological-sort"],
    "sampleTestcases": [
      {
        "input": "2\n[[1,0]]",
        "expectedOutput": "true",
        "orderIndex": 1,
        "explanation": "There are 2 courses. To take course 1 you should have finished course 0."
      },
      {
        "input": "2\n[[1,0],[0,1]]",
        "expectedOutput": "false",
        "orderIndex": 2,
        "explanation": "It's impossible due to circular dependency."
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "This problem is equivalent to detecting a cycle in a directed graph."
      },
      {
        "order": 2,
        "content": "Use DFS with three states: unvisited, visiting, and visited to detect cycles."
      },
      {
        "order": 3,
        "content": "Alternatively, use topological sort with Kahn's algorithm (BFS)."
      }
    ]
  },
  {
    "title": "Implement Trie (Prefix Tree)",
    "slug": "implement-trie",
    "description": "A **trie** (pronounced as \"try\") or **prefix tree** is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n- `Trie()` Initializes the trie object.\n- `void insert(String word)` Inserts the string `word` into the trie.\n- `boolean search(String word)` Returns `true` if the string `word` is in the trie, and `false` otherwise.\n- `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.\n\n**Example 1:**\n\n```\nInput\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n```",
    "constraints": "- `1 <= word.length, prefix.length <= 2000`\n- `word` and `prefix` consist only of lowercase English letters.\n- At most `3 * 10^4` calls in total will be made to `insert`, `search`, and `startsWith`.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["trie", "hash-table", "string", "design"],
    "tagSlugs": ["trie", "hash-table", "string", "design"],
    "sampleTestcases": [
      {
        "input": "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"],[\"app\"],[\"app\"]]",
        "expectedOutput": "[null,null,true,false,true,null,true]",
        "orderIndex": 1,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Each node in the trie should have a map/array of children and a boolean flag to mark end of word."
      },
      {
        "order": 2,
        "content": "For insert, traverse the trie creating nodes as needed."
      },
      {
        "order": 3,
        "content": "For search, traverse the trie and check if the final node is marked as end of word."
      }
    ]
  },
  {
    "title": "Kth Largest Element in an Array",
    "slug": "kth-largest-element-in-array",
    "description": "Given an integer array `nums` and an integer `k`, return the `kth` largest element in the array.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nCan you solve it without sorting?\n\n**Example 1:**\n\n```\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n```\n\n**Example 2:**\n\n```\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n```",
    "constraints": "- `1 <= k <= nums.length <= 10^5`\n- `-10^4 <= nums[i] <= 10^4`",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": [
      "array",
      "divide-and-conquer",
      "sorting",
      "heap",
      "quickselect"
    ],
    "tagSlugs": ["array", "heap", "sorting", "quickselect"],
    "sampleTestcases": [
      {
        "input": "[3,2,1,5,6,4]\n2",
        "expectedOutput": "5",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[3,2,3,1,2,4,5,5,6]\n4",
        "expectedOutput": "4",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use a min heap of size k to keep track of the k largest elements."
      },
      {
        "order": 2,
        "content": "Alternatively, use Quickselect algorithm for O(n) average time complexity."
      }
    ]
  },
  {
    "title": "Find Median from Data Stream",
    "slug": "find-median-from-data-stream",
    "description": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nImplement the MedianFinder class:\n\n- `MedianFinder()` initializes the `MedianFinder` object.\n- `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far.\n\n**Example 1:**\n\n```\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n```",
    "constraints": "- `-10^5 <= num <= 10^5`\n- There will be at least one element in the data structure before calling `findMedian`.\n- At most `5 * 10^4` calls will be made to `addNum` and `findMedian`.",
    "difficulty": "hard",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["heap", "design", "sorting", "data-stream"],
    "tagSlugs": ["heap", "design", "two-pointers", "data-stream"],
    "sampleTestcases": [
      {
        "input": "[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\n[[],[1],[2],[],[3],[]]",
        "expectedOutput": "[null,null,null,1.5,null,2.0]",
        "orderIndex": 1,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use two heaps: a max heap for the smaller half and a min heap for the larger half."
      },
      {
        "order": 2,
        "content": "Keep the heaps balanced so their sizes differ by at most 1."
      },
      {
        "order": 3,
        "content": "The median is either the top of one heap or the average of both tops."
      }
    ]
  },
  {
    "title": "Longest Palindromic Substring",
    "slug": "longest-palindromic-substring",
    "description": "Given a string `s`, return the longest palindromic substring in `s`.\n\n**Example 1:**\n\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n\n```\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```",
    "constraints": "- `1 <= s.length <= 1000`\n- `s` consist of only digits and English letters.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["string", "dynamic-programming"],
    "tagSlugs": ["string", "dynamic-programming", "two-pointers"],
    "sampleTestcases": [
      {
        "input": "\"babad\"",
        "expectedOutput": "\"bab\"",
        "orderIndex": 1,
        "explanation": "\"aba\" is also a valid answer."
      },
      {
        "input": "\"cbbd\"",
        "expectedOutput": "\"bb\"",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Expand around center: for each character, try expanding outward to find palindromes."
      },
      {
        "order": 2,
        "content": "Consider both odd-length palindromes (single center) and even-length palindromes (two centers)."
      },
      {
        "order": 3,
        "content": "Dynamic programming approach: dp[i][j] represents whether substring from i to j is a palindrome."
      }
    ]
  },
  {
    "title": "Group Anagrams",
    "slug": "group-anagrams",
    "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n**Example 1:**\n\n```\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n```\n\n**Example 2:**\n\n```\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n```\n\n**Example 3:**\n\n```\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n```",
    "constraints": "- `1 <= strs.length <= 10^4`\n- `0 <= strs[i].length <= 100`\n- `strs[i]` consists of lowercase English letters.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "hash-table", "string", "sorting"],
    "tagSlugs": ["array", "hash-table", "string", "sorting"],
    "sampleTestcases": [
      {
        "input": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "expectedOutput": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[\"\"]",
        "expectedOutput": "[[\"\"]]",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[\"a\"]",
        "expectedOutput": "[[\"a\"]]",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use a hash map where the key is the sorted version of each string."
      },
      {
        "order": 2,
        "content": "All anagrams will have the same sorted string as their key."
      }
    ]
  },
  {
    "title": "3Sum",
    "slug": "3sum",
    "description": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n**Example 1:**\n\n```\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\n```\n\n**Example 2:**\n\n```\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n```\n\n**Example 3:**\n\n```\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\n```",
    "constraints": "- `3 <= nums.length <= 3000`\n- `-10^5 <= nums[i] <= 10^5`",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "two-pointers", "sorting"],
    "tagSlugs": ["array", "two-pointers", "sorting"],
    "sampleTestcases": [
      {
        "input": "[-1,0,1,2,-1,-4]",
        "expectedOutput": "[[-1,-1,2],[-1,0,1]]",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[0,1,1]",
        "expectedOutput": "[]",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[0,0,0]",
        "expectedOutput": "[[0,0,0]]",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Sort the array first to make it easier to avoid duplicates and use two pointers."
      },
      {
        "order": 2,
        "content": "For each element, use two pointers to find pairs that sum to the negative of that element."
      },
      {
        "order": 3,
        "content": "Skip duplicate values to avoid duplicate triplets in the result."
      }
    ]
  },
  {
    "title": "Container With Most Water",
    "slug": "container-with-most-water",
    "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\n**Example 1:**\n\n```\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The vertical lines are at indices 1 and 8 with heights 8 and 7. The area is min(8,7) * (8-1) = 49.\n```\n\n**Example 2:**\n\n```\nInput: height = [1,1]\nOutput: 1\n```",
    "constraints": "- `n == height.length`\n- `2 <= n <= 10^5`\n- `0 <= height[i] <= 10^4`",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "two-pointers", "greedy"],
    "tagSlugs": ["array", "two-pointers", "greedy"],
    "sampleTestcases": [
      {
        "input": "[1,8,6,2,5,4,8,3,7]",
        "expectedOutput": "49",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[1,1]",
        "expectedOutput": "1",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use two pointers starting from both ends of the array."
      },
      {
        "order": 2,
        "content": "Move the pointer with the smaller height inward, as moving the larger one won't increase the area."
      },
      {
        "order": 3,
        "content": "Keep track of the maximum area found."
      }
    ]
  },
  {
    "title": "Trapping Rain Water",
    "slug": "trapping-rain-water",
    "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n```\n\n**Example 2:**\n\n```\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```",
    "constraints": "- `n == height.length`\n- `1 <= n <= 2 * 10^4`\n- `0 <= height[i] <= 10^5`",
    "difficulty": "hard",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": [
      "array",
      "two-pointers",
      "dynamic-programming",
      "stack",
      "monotonic-stack"
    ],
    "tagSlugs": ["array", "two-pointers", "dynamic-programming", "stack"],
    "sampleTestcases": [
      {
        "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
        "expectedOutput": "6",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[4,2,0,3,2,5]",
        "expectedOutput": "9",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "For each position, the water level is determined by the minimum of the maximum heights to its left and right."
      },
      {
        "order": 2,
        "content": "Use two pointers approach: track max heights from both sides and move the pointer with smaller max height."
      },
      {
        "order": 3,
        "content": "Alternatively, use dynamic programming to precompute max heights from left and right for each position."
      }
    ]
  },
  {
    "title": "Longest Consecutive Sequence",
    "slug": "longest-consecutive-sequence",
    "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in `O(n)` time.\n\n**Example 1:**\n\n```\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n**Example 2:**\n\n```\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n```",
    "constraints": "- `0 <= nums.length <= 10^5`\n- `-10^9 <= nums[i] <= 10^9`",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "hash-table", "union-find"],
    "tagSlugs": ["array", "hash-table", "union-find"],
    "sampleTestcases": [
      {
        "input": "[100,4,200,1,3,2]",
        "expectedOutput": "4",
        "orderIndex": 1,
        "explanation": "The longest consecutive sequence is [1, 2, 3, 4]."
      },
      {
        "input": "[0,3,7,2,5,8,4,6,0,1]",
        "expectedOutput": "9",
        "orderIndex": 2,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use a hash set to store all numbers for O(1) lookup."
      },
      {
        "order": 2,
        "content": "For each number, check if it's the start of a sequence (i.e., num-1 is not in the set)."
      },
      {
        "order": 3,
        "content": "If it's a start, count how many consecutive numbers follow it."
      }
    ]
  },
  {
    "title": "Word Search",
    "slug": "word-search",
    "description": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n**Example 1:**\n\n```\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true\n```\n\n**Example 3:**\n\n```\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false\n```",
    "constraints": "- `m == board.length`\n- `n = board[i].length`\n- `1 <= m, n <= 6`\n- `1 <= word.length <= 15`\n- `board` and `word` consists of only lowercase and uppercase English letters.",
    "difficulty": "medium",
    "isPremium": false,
    "isActive": true,
    "timeLimitMs": 2000,
    "memoryLimitKb": 256000,
    "topicSlugs": ["array", "backtracking", "matrix"],
    "tagSlugs": ["array", "backtracking", "matrix", "depth-first-search"],
    "sampleTestcases": [
      {
        "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCCED\"",
        "expectedOutput": "true",
        "orderIndex": 1,
        "explanation": null
      },
      {
        "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"SEE\"",
        "expectedOutput": "true",
        "orderIndex": 2,
        "explanation": null
      },
      {
        "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCB\"",
        "expectedOutput": "false",
        "orderIndex": 3,
        "explanation": null
      }
    ],
    "hints": [
      {
        "order": 1,
        "content": "Use backtracking with DFS to explore all possible paths."
      },
      {
        "order": 2,
        "content": "Mark cells as visited during the search and unmark them when backtracking."
      },
      {
        "order": 3,
        "content": "Start the search from each cell that matches the first character of the word."
      }
    ]
  }
]
